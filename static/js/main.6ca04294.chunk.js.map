{"version":3,"sources":["imgHelper.js","gameLogic.js","components/cell.jsx","components/gameOverDialog.jsx","components/gameGrid.jsx","components/menu.jsx","components/header.jsx","App.js","index.js"],"names":["imageName","determineCellImage","cell","blame","image","status","cellStatus","COVERED_CLEAR","COVERED_FLAG","COVERED_QUESTION","UNCOVERED","type","cellType","MINE","nearMines","console","error","EMPTY","createGameMatrix","totalRows","totalCols","totalMines","matrix","mineCount","cellId","totalCells","mineProbability","log","rowIndex","row","colIndex","Math","random","newCell","id","push","GameCell","state","isUncovered","handleLeftClick","props","notifyClick","handleRightClick","e","preventDefault","this","onClick","onContextMenu","className","src","alt","Component","PaperComponent","Paper","GameOverDialog","Dialog","open","Grid","container","direction","justify","alignItems","isVictory","Button","variant","color","restartGame","backToMenu","Typography","GameGrid","isGameOver","renderGameGrid","cellsGrid","i","cellsRow","j","key","gameMatrix","gameId","isRightClick","onCellClick","length","setState","renderGameOverModal","handleSaveGameClick","saveGameAndReturnToMenu","col","clickedCell","newStatus","currentStatus","getNextStatus","updatedGameMatrix","uncoverEmptyCells","lastRow","lastCol","uncoverAllCoveredCells","checkVictory","Fragment","Menu","rows","cols","gameOver","showMenu","calcMineProbability","mines","result","toFixed","startGame","newGameMatrix","parseInt","handleStartClick","localStorage","setItem","handleColsChange","target","value","handleRowsChange","handleMinesChange","handleContinueClick","savedGameMatrix","JSON","parse","getItem","renderContinueButton","saveGameAndShowMenu","stringify","TextField","label","defaultValue","onChange","Header","item","xs","App","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.6ca04294.chunk.js","sourcesContent":["import { cellStatus, cellType } from \"./gameLogic\";\r\n\r\nexport const imageName = {\r\n  COVERED_CLEAR_IMG: \"initial\",\r\n  COVERED_FLAG_IMG: \"flag\",\r\n  COVERED_QUESTION_IMG: \"question\",\r\n  UNCOVERED_EMPTY_IMG_ROOT: \"empty-\",\r\n  UNCOVERED_MINE_IMG: \"mine\",\r\n  UNCOVERED_BLAMED_MINE_IMG: \"redmine\",\r\n};\r\n\r\n/**\r\n * Determina la imagen que corresponde según estado y tipo de celda\r\n *\r\n * @param {object} cell Objeto de la celda con status, type y nearMines\r\n * @param {boolean} blame Indica si fue la celda culpable de una derrota\r\n */\r\nexport const determineCellImage = (cell, blame) => {\r\n  let image;\r\n\r\n  switch (cell.status) {\r\n    case cellStatus.COVERED_CLEAR:\r\n      image = imageName.COVERED_CLEAR_IMG;\r\n      break;\r\n    case cellStatus.COVERED_FLAG:\r\n      image = imageName.COVERED_FLAG_IMG;\r\n      break;\r\n    case cellStatus.COVERED_QUESTION:\r\n      image = imageName.COVERED_QUESTION_IMG;\r\n      break;\r\n    case cellStatus.UNCOVERED:\r\n      if (cell.type === cellType.MINE)\r\n        if (blame) {\r\n          image = imageName.UNCOVERED_BLAMED_MINE_IMG;\r\n        } else {\r\n          image = imageName.UNCOVERED_MINE_IMG;\r\n        }\r\n      else {\r\n        // Si es una celda descubierta sin mina, se compone el nombre de la\r\n        // imagen con la raíz de celda vacía y el número de minas aledañas\r\n        image = imageName.UNCOVERED_EMPTY_IMG_ROOT + cell.nearMines;\r\n      }\r\n      break;\r\n    default:\r\n      console.error(`No se pudo determinar la imagen`);\r\n      console.error(cell, blame);\r\n      image = imageName.COVERED_CLEAR_IMG;\r\n      break;\r\n  }\r\n\r\n  return image;\r\n};\r\n","import { imageName, determineCellImage } from \"./imgHelper\";\r\n\r\nexport const cellStatus = {\r\n  COVERED_CLEAR: \"CC\",\r\n  COVERED_FLAG: \"CF\",\r\n  COVERED_QUESTION: \"CQ\",\r\n  UNCOVERED: \"UC\",\r\n};\r\n\r\nexport const cellType = {\r\n  EMPTY: \"E\",\r\n  MINE: \"M\",\r\n};\r\n\r\nexport const createGameMatrix = (totalRows, totalCols, totalMines) => {\r\n  /*\r\n  La matriz del juego contiene objetos con la forma\r\n    {\r\n      type: EMPTY | MINE,\r\n      nearMines: Int (cantidad de minas alrededor),\r\n      status: COVERED_CLEAR | COVERED_FLAG | COVERED_QUESTION | UNCOVERED,\r\n      image: COVERED_CLEAR_IMG | COVERED_FLAG_IMG  | COVERED_QUESTION_IMG |\r\n             UNCOVERED_EMPTY_IMG_ROOT | UNCOVERED_MINE_IMG | UNCOVERED_BLAMED_MINE_IMG\r\n    }\r\n  */\r\n\r\n  // Matriz con la información del juego\r\n  let matrix = [];\r\n\r\n  // Contador para ir viendo si ya están puestas todas la minas\r\n  let mineCount = 0;\r\n\r\n  let cellId = 0;\r\n\r\n  // Total de cajas\r\n  const totalCells = totalRows * totalCols;\r\n\r\n  // Probabilidad de que haya una mina en cada celda\r\n  const mineProbability = totalMines / totalCells;\r\n\r\n  console.log(\r\n    `Creating Game - mine probability: ${mineProbability} - total cells: ${totalCells}`\r\n  );\r\n\r\n  // Se arma la matriz con dos loops\r\n  for (let rowIndex = 0; rowIndex < totalRows; rowIndex++) {\r\n    // Fila nueva...\r\n    let row = [];\r\n    for (let colIndex = 0; colIndex < totalCols; colIndex++) {\r\n      let type = cellType.EMPTY;\r\n\r\n      // Si faltan minas por colocar, se determina aleatoriamente si corresponde\r\n      if (mineCount < totalMines) {\r\n        // Si la cantidad de minas que faltan por ubicar coincide con la\r\n        // cantidad de cajas que falta crear, todas serán minas\r\n        const createdCells = rowIndex * totalCols + colIndex + 1;\r\n\r\n        if (totalCells - createdCells <= mineCount) {\r\n          type = cellType.MINE;\r\n        } else {\r\n          // Si no (si hay margen) se decide por random\r\n          if (Math.random() < mineProbability) {\r\n            type = cellType.MINE;\r\n          }\r\n        }\r\n      }\r\n\r\n      // Se agrega la caja en la fila, inicialmetne con el conteo de minas adyacentes en cero\r\n      let newCell = {\r\n        type,\r\n        nearMines: 0,\r\n      };\r\n\r\n      // Si es una mina, se incrementan los contadores de las celdas adyacentes\r\n      if (type === cellType.MINE) {\r\n        // De paso, se incrementa el conteo de minas\r\n        mineCount++;\r\n\r\n        // Celda a la izquierda si existe y no es una mina\r\n        if (colIndex > 0)\r\n          if (row[colIndex - 1].type !== cellType.MINE)\r\n            row[colIndex - 1].nearMines++;\r\n\r\n        // Celdas de la fila anterior si existe\r\n        if (rowIndex > 0) {\r\n          // Celda superior izquierda si existe\r\n          if (colIndex > 0)\r\n            if (matrix[rowIndex - 1][colIndex - 1].type !== cellType.MINE)\r\n              matrix[rowIndex - 1][colIndex - 1].nearMines++;\r\n\r\n          // Celda superior media\r\n          if (matrix[rowIndex - 1][colIndex].type !== cellType.MINE)\r\n            matrix[rowIndex - 1][colIndex].nearMines++;\r\n\r\n          // Celda superior derecha si existe\r\n          if (colIndex < totalCols - 1)\r\n            if (matrix[rowIndex - 1][colIndex + 1].type !== cellType.MINE)\r\n              matrix[rowIndex - 1][colIndex + 1].nearMines++;\r\n        }\r\n      } else {\r\n        // Si no es una mina, se contabilizan minas adyacentes\r\n\r\n        // Celda a la izquierda si existe\r\n        if (colIndex > 0) {\r\n          if (row[colIndex - 1].type === cellType.MINE) newCell.nearMines++;\r\n        }\r\n\r\n        // Celdas de la fila anterior si existe\r\n        if (rowIndex > 0) {\r\n          // Celda superior izquierda si existe\r\n          if (colIndex > 0) {\r\n            if (matrix[rowIndex - 1][colIndex - 1].type === cellType.MINE)\r\n              newCell.nearMines++;\r\n          }\r\n          // Celda superior media\r\n          if (matrix[rowIndex - 1][colIndex].type === cellType.MINE)\r\n            newCell.nearMines++;\r\n          // Celda superior derecha si existe\r\n          if (colIndex < totalCols - 1) {\r\n            if (matrix[rowIndex - 1][colIndex + 1].type === cellType.MINE)\r\n              newCell.nearMines++;\r\n          }\r\n        }\r\n      }\r\n\r\n      newCell.status = cellStatus.COVERED_CLEAR;\r\n      newCell.image = imageName.COVERED_CLEAR_IMG;\r\n      newCell.id = cellId++;\r\n\r\n      row.push(newCell);\r\n    }\r\n\r\n    // Se agrega la fila creada a la matriz\r\n    matrix.push(row);\r\n  }\r\n\r\n  /*\r\n  // Console.table para hacer trampa :)\r\n  console.table(\r\n    matrix.map((row) =>\r\n      row.map((cell) => (cell.type === cellType.MINE ? 0 : \"\"))\r\n    )\r\n  );\r\n  */\r\n\r\n  return matrix;\r\n};\r\n\r\n/**\r\n * Obtiene el próximo estado de una celda al recibir un click\r\n *\r\n * @param {string} currentStatus status actual (valores de cellStatus)\r\n * @param {boolean} isRightClick true si es click derecho, falso si es izquierdo\r\n */\r\nexport const getNextStatus = (currentStatus, isRightClick) => {\r\n  // Si la celda ya fue descubierta, no se modifica\r\n  if (currentStatus === cellStatus.UNCOVERED) return cellStatus.UNCOVERED;\r\n\r\n  if (isRightClick) {\r\n    // Si es click derecho, va ciclando en las distintas marcas\r\n    if (currentStatus === cellStatus.COVERED_CLEAR)\r\n      return cellStatus.COVERED_FLAG;\r\n    if (currentStatus === cellStatus.COVERED_FLAG)\r\n      return cellStatus.COVERED_QUESTION;\r\n    if (currentStatus === cellStatus.COVERED_QUESTION)\r\n      return cellStatus.COVERED_CLEAR;\r\n  } else {\r\n    // Si es click izquierdo, descubre la celda\r\n    return cellStatus.UNCOVERED;\r\n  }\r\n};\r\n\r\n/**\r\n * Determina si ya es una victoria\r\n *\r\n * @param {Array} gameMatrix Matriz con la información del juego en el momento\r\n */\r\nexport const checkVictory = (gameMatrix) => {\r\n  for (let row = 0; row < gameMatrix.length; row++) {\r\n    for (let col = 0; col < gameMatrix[row].length; col++) {\r\n      const cell = gameMatrix[row][col];\r\n\r\n      // Para que haya victoria, cada celda tiene que estar descubierta o,\r\n      // si está cubierta, estar marcada con una bandera y ser efectivamente una mina\r\n\r\n      if (\r\n        cell.status !== cellStatus.UNCOVERED &&\r\n        (cell.status !== cellStatus.COVERED_FLAG || cell.type !== cellType.MINE)\r\n      ) {\r\n        return false;\r\n      }\r\n    }\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\n/**\r\n * Cambia a descubierto el estado de todas las celdas de una zona vacía a partir de las\r\n * coordenadas de una celda vacía descubierta\r\n *\r\n * @param {Array} gameMatrix Matriz de juego en estado actual\r\n * @param {number} row Fila de la celda vacía descubierta\r\n * @param {number} col Columna de la celda vacía descubierta\r\n */\r\nexport const uncoverEmptyCells = (gameMatrix, row, col) => {\r\n  // Se verifican las celdas adyacentes (si existen) y para cada una\r\n  // se vuelve a ejecutar recursivamente la función si también está\r\n  // vacía. Se actualiza la imagen que corresponde a cada celda\r\n\r\n  const lastRow = gameMatrix.length - 1;\r\n  const lastCol = gameMatrix[0].length - 1;\r\n\r\n  // Celda superior izquierda\r\n  if (row > 0 && col > 0) {\r\n    if (\r\n      gameMatrix[row - 1][col - 1].type === cellType.EMPTY &&\r\n      gameMatrix[row - 1][col - 1].status !== cellStatus.UNCOVERED\r\n    ) {\r\n      gameMatrix[row - 1][col - 1].status = cellStatus.UNCOVERED;\r\n      gameMatrix[row - 1][col - 1].image =\r\n        imageName.UNCOVERED_EMPTY_IMG_ROOT +\r\n        gameMatrix[row - 1][col - 1].nearMines;\r\n      if (gameMatrix[row - 1][col - 1].nearMines === 0) {\r\n        gameMatrix = uncoverEmptyCells(gameMatrix, row - 1, col - 1);\r\n      }\r\n    }\r\n  }\r\n\r\n  // Celda superior media\r\n  if (row > 0) {\r\n    if (\r\n      gameMatrix[row - 1][col].type === cellType.EMPTY &&\r\n      gameMatrix[row - 1][col].status !== cellStatus.UNCOVERED\r\n    ) {\r\n      gameMatrix[row - 1][col].status = cellStatus.UNCOVERED;\r\n      gameMatrix[row - 1][col].image =\r\n        imageName.UNCOVERED_EMPTY_IMG_ROOT + gameMatrix[row - 1][col].nearMines;\r\n      if (gameMatrix[row - 1][col].nearMines === 0) {\r\n        gameMatrix = uncoverEmptyCells(gameMatrix, row - 1, col);\r\n      }\r\n    }\r\n  }\r\n\r\n  // Celda superior derecha\r\n  if (row > 0 && col < lastCol) {\r\n    if (\r\n      gameMatrix[row - 1][col + 1].type === cellType.EMPTY &&\r\n      gameMatrix[row - 1][col + 1].status !== cellStatus.UNCOVERED\r\n    ) {\r\n      gameMatrix[row - 1][col + 1].status = cellStatus.UNCOVERED;\r\n      gameMatrix[row - 1][col + 1].image =\r\n        imageName.UNCOVERED_EMPTY_IMG_ROOT +\r\n        gameMatrix[row - 1][col + 1].nearMines;\r\n      if (gameMatrix[row - 1][col + 1].nearMines === 0) {\r\n        gameMatrix = uncoverEmptyCells(gameMatrix, row - 1, col + 1);\r\n      }\r\n    }\r\n  }\r\n\r\n  // Celda izquierda\r\n  if (col > 0) {\r\n    if (\r\n      gameMatrix[row][col - 1].type === cellType.EMPTY &&\r\n      gameMatrix[row][col - 1].status !== cellStatus.UNCOVERED\r\n    ) {\r\n      gameMatrix[row][col - 1].status = cellStatus.UNCOVERED;\r\n      gameMatrix[row][col - 1].image =\r\n        imageName.UNCOVERED_EMPTY_IMG_ROOT + gameMatrix[row][col - 1].nearMines;\r\n      if (gameMatrix[row][col - 1].nearMines === 0) {\r\n        gameMatrix = uncoverEmptyCells(gameMatrix, row, col - 1);\r\n      }\r\n    }\r\n  }\r\n\r\n  // Celda derecha\r\n  if (col < lastCol) {\r\n    if (\r\n      gameMatrix[row][col + 1].type === cellType.EMPTY &&\r\n      gameMatrix[row][col + 1].status !== cellStatus.UNCOVERED\r\n    ) {\r\n      gameMatrix[row][col + 1].status = cellStatus.UNCOVERED;\r\n      gameMatrix[row][col + 1].image =\r\n        imageName.UNCOVERED_EMPTY_IMG_ROOT + gameMatrix[row][col + 1].nearMines;\r\n      if (gameMatrix[row][col + 1].nearMines === 0) {\r\n        gameMatrix = uncoverEmptyCells(gameMatrix, row, col + 1);\r\n      }\r\n    }\r\n  }\r\n\r\n  // Celda inferior izquierda\r\n  if (row < lastRow && col > 0) {\r\n    if (\r\n      gameMatrix[row + 1][col - 1].type === cellType.EMPTY &&\r\n      gameMatrix[row + 1][col - 1].status !== cellStatus.UNCOVERED\r\n    ) {\r\n      gameMatrix[row + 1][col - 1].status = cellStatus.UNCOVERED;\r\n      gameMatrix[row + 1][col - 1].image =\r\n        imageName.UNCOVERED_EMPTY_IMG_ROOT +\r\n        gameMatrix[row + 1][col - 1].nearMines;\r\n      if (gameMatrix[row + 1][col - 1].nearMines === 0) {\r\n        gameMatrix = uncoverEmptyCells(gameMatrix, row + 1, col - 1);\r\n      }\r\n    }\r\n  }\r\n\r\n  // Celda inferior media\r\n  if (row < lastRow) {\r\n    if (\r\n      gameMatrix[row + 1][col].type === cellType.EMPTY &&\r\n      gameMatrix[row + 1][col].status !== cellStatus.UNCOVERED\r\n    ) {\r\n      gameMatrix[row + 1][col].status = cellStatus.UNCOVERED;\r\n      gameMatrix[row + 1][col].image =\r\n        imageName.UNCOVERED_EMPTY_IMG_ROOT + gameMatrix[row + 1][col].nearMines;\r\n      if (gameMatrix[row + 1][col].nearMines === 0) {\r\n        gameMatrix = uncoverEmptyCells(gameMatrix, row + 1, col);\r\n      }\r\n    }\r\n  }\r\n\r\n  // Celda inferior derecha\r\n  if (row < lastRow && col < lastCol) {\r\n    if (\r\n      gameMatrix[row + 1][col + 1].type === cellType.EMPTY &&\r\n      gameMatrix[row + 1][col + 1].status !== cellStatus.UNCOVERED\r\n    ) {\r\n      gameMatrix[row + 1][col + 1].status = cellStatus.UNCOVERED;\r\n      gameMatrix[row + 1][col + 1].image =\r\n        imageName.UNCOVERED_EMPTY_IMG_ROOT +\r\n        gameMatrix[row + 1][col + 1].nearMines;\r\n      if (gameMatrix[row + 1][col + 1].nearMines === 0) {\r\n        gameMatrix = uncoverEmptyCells(gameMatrix, row + 1, col + 1);\r\n      }\r\n    }\r\n  }\r\n\r\n  return gameMatrix;\r\n};\r\n\r\n\r\n/**\r\n * Revela todas las celdas que no hubieran sido reveladas ya\r\n * \r\n * @param {Array} gameMatrix \r\n */\r\nexport const uncoverAllCoveredCells = (gameMatrix) => {\r\n\r\n  for (let row = 0; row < gameMatrix.length; row++) {\r\n    for (let col = 0; col < gameMatrix[0].length; col++) {\r\n\r\n      if (gameMatrix[row][col].status !== cellStatus.UNCOVERED) {\r\n        gameMatrix[row][col].status = cellStatus.UNCOVERED;\r\n        gameMatrix[row][col].image = determineCellImage(gameMatrix[row][col], false);        \r\n      }\r\n\r\n    }\r\n    \r\n  }\r\n\r\n  return gameMatrix;\r\n}","import React, { Component } from \"react\";\r\nimport { cellStatus } from \"../gameLogic\";\r\n\r\nclass GameCell extends Component {\r\n  state = {\r\n    isUncovered: false,\r\n  };\r\n\r\n  handleLeftClick = () => {\r\n    this.props.notifyClick(false);\r\n  };\r\n\r\n  handleRightClick = (e) => {\r\n    // Evitar el menú contextual del navegador\r\n    e.preventDefault();\r\n\r\n    this.props.notifyClick(true);\r\n  };\r\n\r\n  render() {\r\n    return this.props.status !== cellStatus.UNCOVERED ? (\r\n      <div onClick={this.handleLeftClick} onContextMenu={this.handleRightClick}>\r\n        <img className=\"cell\" src={`img/box-${this.props.image}.png`} alt=\"\"/>\r\n      </div>\r\n    ) : (\r\n      <div>\r\n        <img className=\"cell\" src={`img/box-${this.props.image}.png`} alt=\"\"/>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default GameCell;\r\n","import React, { Component } from \"react\";\r\nimport {\r\n  Button,\r\n  Dialog,\r\n  DialogTitle,\r\n  Grid,\r\n  Paper,\r\n  Typography,\r\n} from \"@material-ui/core\";\r\nimport Draggable from \"react-draggable\";\r\n\r\nfunction PaperComponent(props) {\r\n  return (\r\n    <Draggable>\r\n      <Paper {...props} />\r\n    </Draggable>\r\n  );\r\n}\r\n\r\nclass GameOverDialog extends Component {\r\n  render() {\r\n    return (\r\n      <Dialog\r\n        open={true}\r\n        PaperComponent={PaperComponent}\r\n      >\r\n        <Grid container direction=\"column\" justify=\"center\" alignItems=\"center\">\r\n          <img\r\n            src={\r\n              this.props.isVictory\r\n                ? \"img/roman-victory.jpg\"\r\n                : \"img/roman-defeat.jpg\"\r\n            }\r\n            alt=\"\"\r\n          />\r\n          <Button\r\n            id=\"btn-restart\"\r\n            className=\"btn-end-dialog\"\r\n            variant=\"contained\"\r\n            color=\"primary\"\r\n            onClick={this.props.restartGame}\r\n          >\r\n            Reiniciar con la misma configuración\r\n          </Button>\r\n          <Button\r\n            id=\"btn-backtomenu\"\r\n            className=\"btn-end-dialog\"\r\n            variant=\"contained\"\r\n            color=\"primary\"\r\n            onClick={this.props.backToMenu}\r\n          >\r\n            Volver al menú\r\n          </Button>\r\n          <Typography variant=\"caption\" className=\"footnote\">\r\n            (podés mover esta ventana)\r\n          </Typography>\r\n        </Grid>\r\n      </Dialog>\r\n    );\r\n  }\r\n}\r\n\r\nexport default GameOverDialog;\r\n","import React, { Component } from \"react\";\r\nimport {\r\n  getNextStatus,\r\n  uncoverEmptyCells,\r\n  uncoverAllCoveredCells,\r\n  checkVictory,\r\n  cellStatus,\r\n  cellType,\r\n} from \"../gameLogic\";\r\nimport { Button } from \"@material-ui/core\";\r\nimport GameCell from \"./cell\";\r\nimport GameOverDialog from \"./gameOverDialog\";\r\nimport { determineCellImage } from \"../imgHelper\";\r\n\r\nclass GameGrid extends Component {\r\n  state = {\r\n    isGameOver: false,\r\n    isVictory: false,\r\n  };\r\n\r\n  // Crea la grilla\r\n  renderGameGrid = () => {\r\n    let cellsGrid = [];\r\n\r\n    // Se arma la grilla con la matriz de datos\r\n    for (let i = 0; i < this.props.gameMatrix.length; i++) {\r\n      let cellsRow = [];\r\n\r\n      for (let j = 0; j < this.props.gameMatrix[i].length; j++) {\r\n        // Se agrega la caja en la fila\r\n        cellsRow.push(\r\n          <GameCell\r\n            // key con gameId para que re-renderice cuando se reinicia el juego\r\n            key={`cell-${this.props.gameMatrix[i][j].id}-game-${this.props.gameId}`}\r\n            image={this.props.gameMatrix[i][j].image}\r\n            status={this.props.gameMatrix[i][j].status}\r\n            notifyClick={(isRightClick) => this.onCellClick(i, j, isRightClick)}\r\n          />\r\n        );\r\n      }\r\n\r\n      // Se agrega la fila creada a la matriz\r\n      cellsGrid.push(\r\n        <div key={`row${i}_G${this.props.gameId}`} className=\"row\">\r\n          {cellsRow}\r\n        </div>\r\n      );\r\n    }\r\n\r\n    return cellsGrid;\r\n  };\r\n\r\n  // Recibe notificación de click en una celda, retorna imagen a mostrar\r\n  onCellClick(row, col, isRightClick) {\r\n    const clickedCell = this.props.gameMatrix[row][col];\r\n\r\n    // Si es click izquierdo en una celda que tiene bandera, se ignora\r\n    if (clickedCell.status === cellStatus.COVERED_FLAG && !isRightClick) return;\r\n\r\n    // Calcula el nuevo estado...\r\n    const newStatus = getNextStatus(clickedCell.status, isRightClick);\r\n\r\n    // ... y lo aplica en una copia de la matriz\r\n    let updatedGameMatrix = [...this.props.gameMatrix];\r\n    updatedGameMatrix[row][col].status = newStatus;\r\n\r\n    // Determina la imagen para el nuevo estado\r\n    updatedGameMatrix[row][col].image = determineCellImage(\r\n      updatedGameMatrix[row][col],\r\n      true\r\n    );\r\n\r\n    // Si se descubrió una celda vacía y sin minas cerca, se descubren las vacías aledañas\r\n    if (\r\n      newStatus === cellStatus.UNCOVERED &&\r\n      clickedCell.type === cellType.EMPTY &&\r\n      clickedCell.nearMines === 0\r\n    ) {\r\n      updatedGameMatrix = uncoverEmptyCells(updatedGameMatrix, row, col);\r\n    }\r\n\r\n    // Una vez actualizada, se controla si hay derrota o victoria\r\n\r\n    // Si quedó al descubierto y era una mina, perdió\r\n    // Si no, se chequean condiciones de victoria\r\n    if (\r\n      newStatus === cellStatus.UNCOVERED &&\r\n      clickedCell.type === cellType.MINE\r\n    ) {\r\n      // Se descubren las celdas y se muestra el modal de derrota\r\n      updatedGameMatrix = uncoverAllCoveredCells(updatedGameMatrix);\r\n\r\n      this.setState({\r\n        gameMatrix: updatedGameMatrix,\r\n        isGameOver: true,\r\n        isVictory: false,\r\n      });\r\n    } else if (checkVictory(updatedGameMatrix)) {\r\n      // TODO: si todas las celdas que quedan sin descubrir son minas, se\r\n      // debería dar por ganado igual y marcarlas automáticamente con banderas\r\n      this.setState({\r\n        isGameOver: true,\r\n        isVictory: true,\r\n      });\r\n    } else {\r\n      // Si no hay derrota ni victoria, solo actualiza la matriz de juego con los cambios\r\n      this.setState({\r\n        gameMatrix: updatedGameMatrix,\r\n      });\r\n    }\r\n  }\r\n\r\n  // Retorna al menú principal\r\n  backToMenu = () => {\r\n    this.setState({\r\n      isGameOver: false,\r\n    });\r\n\r\n    this.props.backToMenu();\r\n  };\r\n\r\n  // Reinicia con la misma configuración\r\n  restartGame = () => {\r\n    this.setState({\r\n      isGameOver: false,\r\n    });\r\n\r\n    this.props.restartGame();\r\n  };\r\n\r\n  renderGameOverModal = () => {\r\n    if (this.state.isGameOver) {\r\n      return (\r\n        <GameOverDialog\r\n          isVictory={this.state.isVictory}\r\n          restartGame={this.restartGame}\r\n          backToMenu={this.backToMenu}\r\n        />\r\n      );\r\n    }\r\n  };\r\n\r\n  handleSaveGameClick = () => {\r\n    this.props.saveGameAndReturnToMenu();\r\n  };\r\n\r\n  render() {\r\n    return (\r\n      <React.Fragment>\r\n        {this.renderGameGrid()}\r\n        {this.renderGameOverModal()}\r\n        <Button\r\n          onClick={this.handleSaveGameClick}\r\n          className=\"btn-separated\"\r\n          variant=\"contained\"\r\n          color=\"primary\"\r\n        >\r\n          Guardar juego y volver al menú\r\n        </Button>\r\n      </React.Fragment>\r\n    );\r\n  }\r\n}\r\n\r\nexport default GameGrid;\r\n","import React, { Component } from \"react\";\r\nimport { createGameMatrix } from \"../gameLogic\";\r\nimport GameGrid from \"./gameGrid\";\r\nimport { Grid, TextField, Button, Typography } from \"@material-ui/core\";\r\n\r\nclass Menu extends Component {\r\n  state = {\r\n    gameId: 0,\r\n    rows: 14,\r\n    cols: 10,\r\n    totalMines: 36,\r\n    mineProbability: 0,\r\n    gameMatrix: [],\r\n    gameOver: false,\r\n    showMenu: true,\r\n  };\r\n\r\n  // Calcula y muestra la probabilidad de minas una vez montado el componente\r\n  componentDidMount() {\r\n    this.setState({\r\n      mineProbability: this.calcMineProbability(\r\n        this.state.totalMines,\r\n        this.state.rows,\r\n        this.state.cols\r\n      ),\r\n    });\r\n  }\r\n\r\n  // Función para calcular la probabilidad de mina por celda\r\n  calcMineProbability = (mines, rows, cols) => {\r\n    const result = ((mines / (rows * cols)) * 100).toFixed(2);\r\n\r\n    return result > 100 ? 100 : result;\r\n  };\r\n\r\n  // Creación de un nuevo juego e inicio\r\n  startGame = () => {\r\n    const newGameMatrix = createGameMatrix(\r\n      parseInt(this.state.rows),\r\n      parseInt(this.state.cols),\r\n      parseInt(this.state.totalMines)\r\n    );\r\n\r\n    this.setState({\r\n      gameId: this.state.gameId + 1,\r\n      gameMatrix: newGameMatrix,\r\n      showMenu: false,\r\n    });\r\n  };\r\n\r\n  handleStartClick = () => {\r\n    localStorage.setItem(\"savedGame\", \"\");\r\n    this.startGame();\r\n  };\r\n\r\n  handleColsChange = (e) => {\r\n    this.setState({\r\n      cols: e.target.value,\r\n      mineProbability: this.calcMineProbability(\r\n        this.state.totalMines,\r\n        this.state.rows,\r\n        e.target.value\r\n      ),\r\n    });\r\n  };\r\n\r\n  handleRowsChange = (e) => {\r\n    this.setState({\r\n      rows: e.target.value,\r\n      mineProbability: this.calcMineProbability(\r\n        this.state.totalMines,\r\n        e.target.value,\r\n        this.state.cols\r\n      ),\r\n    });\r\n  };\r\n\r\n  handleMinesChange = (e) => {\r\n    this.setState({\r\n      totalMines: e.target.value,\r\n      mineProbability: this.calcMineProbability(\r\n        e.target.value,\r\n        this.state.rows,\r\n        this.state.cols\r\n      ),\r\n    });\r\n  };\r\n\r\n  restartGame = () => {\r\n    this.startGame();\r\n  };\r\n\r\n  showMenu = () => {\r\n    this.setState({\r\n      showMenu: true,\r\n    });\r\n  };\r\n\r\n  // Continuar juego guardado\r\n  handleContinueClick = () => {\r\n    const savedGameMatrix = JSON.parse(localStorage.getItem(\"savedGame\"));\r\n\r\n    console.log(savedGameMatrix);\r\n\r\n    this.setState({\r\n      gameId: this.state.gameId + 1,\r\n      gameMatrix: savedGameMatrix,\r\n      showMenu: false,\r\n    });\r\n  };\r\n\r\n  // Botón de Continuar juego si hay un juego guardado\r\n  renderContinueButton = () => {\r\n    if (localStorage.getItem(\"savedGame\")) {\r\n      return (\r\n        <Button\r\n          onClick={this.handleContinueClick}\r\n          color=\"primary\"\r\n          className=\"btn-separated\"\r\n        >\r\n          Continuar juego guardado\r\n        </Button>\r\n      );\r\n    }\r\n  };\r\n\r\n  // Guarda el juego actual y muestra el menú\r\n  saveGameAndShowMenu = () => {\r\n    localStorage.setItem(\"savedGame\", JSON.stringify(this.state.gameMatrix));\r\n    this.showMenu();\r\n  };\r\n\r\n  render() {\r\n    return this.state.showMenu ? (\r\n        <Grid\r\n          container\r\n          direction=\"column\"\r\n          justify=\"center\"\r\n          alignItems=\"flex-start\"\r\n        >\r\n          <TextField\r\n            className=\"menu-input\"\r\n            id=\"field-cols\"\r\n            label=\"Columnas\"\r\n            variant=\"outlined\"\r\n            type=\"number\"\r\n            defaultValue={this.state.cols}\r\n            onChange={this.handleColsChange}\r\n          />\r\n          <TextField\r\n            className=\"menu-input\"\r\n            id=\"field-rows\"\r\n            label=\"Filas\"\r\n            variant=\"outlined\"\r\n            type=\"number\"\r\n            defaultValue={this.state.rows}\r\n            onChange={this.handleRowsChange}\r\n          />\r\n          <TextField\r\n            className=\"menu-input\"\r\n            id=\"field-mines\"\r\n            label=\"Cantidad de minas\"\r\n            variant=\"outlined\"\r\n            type=\"number\"\r\n            defaultValue={this.state.totalMines}\r\n            onChange={this.handleMinesChange}\r\n          />\r\n          <Typography variant=\"overline\">\r\n            Probabilidad de mina: {this.state.mineProbability}%\r\n          </Typography>\r\n          <Button\r\n            onClick={this.handleStartClick}\r\n            variant=\"contained\"\r\n            color=\"primary\"\r\n          >\r\n            Jugar\r\n          </Button>\r\n          {this.renderContinueButton()}\r\n        </Grid>\r\n    ) : (\r\n      <GameGrid\r\n        key={`game${this.state.gameId}`}\r\n        gameId={this.state.gameId}\r\n        gameMatrix={this.state.gameMatrix}\r\n        restartGame={this.restartGame}\r\n        backToMenu={this.showMenu}\r\n        saveGameAndReturnToMenu={this.saveGameAndShowMenu}\r\n      />\r\n    );\r\n  }\r\n}\r\n\r\nexport default Menu;\r\n","import React, { Component } from 'react';\r\nimport { Grid } from \"@material-ui/core\";\r\n\r\nclass Header extends Component {\r\n    render() { \r\n        return (\r\n            <Grid container>\r\n                <Grid item xs={12}>\r\n                    <img className=\"logo\" src=\"img/logo.jpg\" alt=\"\"/>\r\n                </Grid>\r\n            </Grid>\r\n        );\r\n    }\r\n}\r\n \r\nexport default Header;","import React from \"react\";\nimport \"./App.css\";\nimport Menu from \"./components/menu\";\nimport Header from \"./components/header\";\n\nfunction App() {\n  return (\n    <React.Fragment>\n      <Header />\n      <Menu />\n    </React.Fragment>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}
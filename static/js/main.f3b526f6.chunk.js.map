{"version":3,"sources":["imgHelper.js","gameLogic.js","components/cell.jsx","components/gameOverDialog.jsx","components/gameGrid.jsx","components/menu.jsx","components/header.jsx","App.js","index.js"],"names":["imageName","determineCellImage","cell","blame","image","status","cellStatus","COVERED_CLEAR","COVERED_FLAG","COVERED_QUESTION","UNCOVERED","type","cellType","MINE","nearMines","console","error","EMPTY","createGameMatrix","totalRows","totalCols","totalMines","matrix","mineCount","totalCells","mineProbability","log","rowIndex","row","colIndex","Math","random","newCell","push","GameCell","state","isUncovered","handleLeftClick","props","notifyClick","handleRightClick","e","preventDefault","this","onClick","onContextMenu","className","src","process","alt","Component","PaperComponent","cancel","Paper","GameOverDialog","Dialog","open","Grid","container","direction","justify","alignItems","isVictory","Button","id","variant","color","restartGame","backToMenu","Typography","GameGrid","isGameOver","renderGameGrid","cellsGrid","i","cellsRow","j","key","gameId","gameMatrix","isRightClick","onCellClick","length","setState","renderGameOverModal","handleSaveGameClick","saveGameAndReturnToMenu","col","clickedCell","newStatus","currentStatus","getNextStatus","updatedGameMatrix","uncoverEmptyCells","lastRow","lastCol","uncoverAllCoveredCells","checkVictory","Fragment","Menu","rows","cols","gameOver","showMenu","calcMineProbability","mines","result","toFixed","startGame","newGameMatrix","parseInt","handleStartClick","localStorage","setItem","handleColsChange","target","value","handleRowsChange","handleMinesChange","handleContinueClick","savedGameMatrix","JSON","parse","getItem","renderContinueButton","saveGameAndShowMenu","stringify","TextField","label","defaultValue","onChange","Header","item","xs","App","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.f3b526f6.chunk.js","sourcesContent":["import { cellStatus, cellType } from \"./gameLogic\";\r\n\r\nexport const imageName = {\r\n  COVERED_CLEAR_IMG: \"initial\",\r\n  COVERED_FLAG_IMG: \"flag\",\r\n  COVERED_QUESTION_IMG: \"question\",\r\n  UNCOVERED_EMPTY_IMG_ROOT: \"empty-\",\r\n  UNCOVERED_MINE_IMG: \"mine\",\r\n  UNCOVERED_BLAMED_MINE_IMG: \"redmine\",\r\n};\r\n\r\n/**\r\n * Determina la imagen que corresponde según estado y tipo de celda\r\n *\r\n * @param {object} cell Objeto de la celda con status, type y nearMines\r\n * @param {boolean} blame Indica si fue la celda culpable de una derrota\r\n */\r\nexport const determineCellImage = (cell, blame) => {\r\n  let image;\r\n\r\n  switch (cell.status) {\r\n    case cellStatus.COVERED_CLEAR:\r\n      image = imageName.COVERED_CLEAR_IMG;\r\n      break;\r\n    case cellStatus.COVERED_FLAG:\r\n      image = imageName.COVERED_FLAG_IMG;\r\n      break;\r\n    case cellStatus.COVERED_QUESTION:\r\n      image = imageName.COVERED_QUESTION_IMG;\r\n      break;\r\n    case cellStatus.UNCOVERED:\r\n      if (cell.type === cellType.MINE)\r\n        if (blame) {\r\n          image = imageName.UNCOVERED_BLAMED_MINE_IMG;\r\n        } else {\r\n          image = imageName.UNCOVERED_MINE_IMG;\r\n        }\r\n      else {\r\n        // Si es una celda descubierta sin mina, se compone el nombre de la\r\n        // imagen con la raíz de celda vacía y el número de minas aledañas\r\n        image = imageName.UNCOVERED_EMPTY_IMG_ROOT + cell.nearMines;\r\n      }\r\n      break;\r\n    default:\r\n      console.error(`No se pudo determinar la imagen`);\r\n      console.error(cell, blame);\r\n      image = imageName.COVERED_CLEAR_IMG;\r\n      break;\r\n  }\r\n\r\n  return image;\r\n};\r\n","import { imageName, determineCellImage } from \"./imgHelper\";\r\n\r\nexport const cellStatus = {\r\n  COVERED_CLEAR: \"CC\",\r\n  COVERED_FLAG: \"CF\",\r\n  COVERED_QUESTION: \"CQ\",\r\n  UNCOVERED: \"UC\",\r\n};\r\n\r\nexport const cellType = {\r\n  EMPTY: \"E\",\r\n  MINE: \"M\",\r\n};\r\n\r\nexport const createGameMatrix = (totalRows, totalCols, totalMines) => {\r\n  /*\r\n  La matriz del juego contiene objetos con la forma\r\n    {\r\n      type: EMPTY | MINE,\r\n      nearMines: Int (cantidad de minas alrededor),\r\n      status: COVERED_CLEAR | COVERED_FLAG | COVERED_QUESTION | UNCOVERED,\r\n      image: COVERED_CLEAR_IMG | COVERED_FLAG_IMG  | COVERED_QUESTION_IMG |\r\n             UNCOVERED_EMPTY_IMG_ROOT | UNCOVERED_MINE_IMG | UNCOVERED_BLAMED_MINE_IMG\r\n    }\r\n  */\r\n\r\n  // Matriz con la información del juego\r\n  let matrix = [];\r\n\r\n  // Contador para ir viendo si ya están puestas todas la minas\r\n  let mineCount = 0;\r\n\r\n  // Total de cajas\r\n  const totalCells = totalRows * totalCols;\r\n\r\n  // Probabilidad de que haya una mina en cada celda\r\n  const mineProbability = totalMines / totalCells;\r\n\r\n  console.log(\r\n    `Creating Game - mine probability: ${mineProbability} - total cells: ${totalCells}`\r\n  );\r\n\r\n  // Se arma la matriz con dos loops\r\n  for (let rowIndex = 0; rowIndex < totalRows; rowIndex++) {\r\n    // Fila nueva...\r\n    let row = [];\r\n    for (let colIndex = 0; colIndex < totalCols; colIndex++) {\r\n      let type = cellType.EMPTY;\r\n\r\n      // Si faltan minas por colocar, se determina aleatoriamente si corresponde\r\n      if (mineCount < totalMines) {\r\n        // Si la cantidad de minas que faltan por ubicar coincide con la\r\n        // cantidad de cajas que falta crear, todas serán minas\r\n        const createdCells = rowIndex * totalCols + colIndex + 1;\r\n\r\n        if (totalCells - createdCells <= mineCount) {\r\n          type = cellType.MINE;\r\n        } else {\r\n          // Si no (si hay margen) se decide por random\r\n          if (Math.random() < mineProbability) {\r\n            type = cellType.MINE;\r\n          }\r\n        }\r\n      }\r\n\r\n      // Se agrega la caja en la fila, inicialmetne con el conteo de minas adyacentes en cero\r\n      let newCell = {\r\n        type,\r\n        nearMines: 0,\r\n      };\r\n\r\n      // Si es una mina, se incrementan los contadores de las celdas adyacentes\r\n      if (type === cellType.MINE) {\r\n        // De paso, se incrementa el conteo de minas\r\n        mineCount++;\r\n\r\n        // Celda a la izquierda si existe y no es una mina\r\n        if (colIndex > 0)\r\n          if (row[colIndex - 1].type !== cellType.MINE)\r\n            row[colIndex - 1].nearMines++;\r\n\r\n        // Celdas de la fila anterior si existe\r\n        if (rowIndex > 0) {\r\n          // Celda superior izquierda si existe\r\n          if (colIndex > 0)\r\n            if (matrix[rowIndex - 1][colIndex - 1].type !== cellType.MINE)\r\n              matrix[rowIndex - 1][colIndex - 1].nearMines++;\r\n\r\n          // Celda superior media\r\n          if (matrix[rowIndex - 1][colIndex].type !== cellType.MINE)\r\n            matrix[rowIndex - 1][colIndex].nearMines++;\r\n\r\n          // Celda superior derecha si existe\r\n          if (colIndex < totalCols - 1)\r\n            if (matrix[rowIndex - 1][colIndex + 1].type !== cellType.MINE)\r\n              matrix[rowIndex - 1][colIndex + 1].nearMines++;\r\n        }\r\n      } else {\r\n        // Si no es una mina, se contabilizan minas adyacentes\r\n\r\n        // Celda a la izquierda si existe\r\n        if (colIndex > 0) {\r\n          if (row[colIndex - 1].type === cellType.MINE) newCell.nearMines++;\r\n        }\r\n\r\n        // Celdas de la fila anterior si existe\r\n        if (rowIndex > 0) {\r\n          // Celda superior izquierda si existe\r\n          if (colIndex > 0) {\r\n            if (matrix[rowIndex - 1][colIndex - 1].type === cellType.MINE)\r\n              newCell.nearMines++;\r\n          }\r\n          // Celda superior media\r\n          if (matrix[rowIndex - 1][colIndex].type === cellType.MINE)\r\n            newCell.nearMines++;\r\n          // Celda superior derecha si existe\r\n          if (colIndex < totalCols - 1) {\r\n            if (matrix[rowIndex - 1][colIndex + 1].type === cellType.MINE)\r\n              newCell.nearMines++;\r\n          }\r\n        }\r\n      }\r\n\r\n      newCell.status = cellStatus.COVERED_CLEAR;\r\n      newCell.image = imageName.COVERED_CLEAR_IMG;\r\n\r\n      row.push(newCell);\r\n    }\r\n\r\n    // Se agrega la fila creada a la matriz\r\n    matrix.push(row);\r\n  }\r\n\r\n  /*\r\n  // Console.table para hacer trampa :)\r\n  console.table(\r\n    matrix.map((row) =>\r\n      row.map((cell) => (cell.type === cellType.MINE ? 0 : \"\"))\r\n    )\r\n  );\r\n  */\r\n\r\n  return matrix;\r\n};\r\n\r\n/**\r\n * Obtiene el próximo estado de una celda al recibir un click\r\n *\r\n * @param {string} currentStatus status actual (valores de cellStatus)\r\n * @param {boolean} isRightClick true si es click derecho, falso si es izquierdo\r\n */\r\nexport const getNextStatus = (currentStatus, isRightClick) => {\r\n  // Si la celda ya fue descubierta, no se modifica\r\n  if (currentStatus === cellStatus.UNCOVERED) return cellStatus.UNCOVERED;\r\n\r\n  if (isRightClick) {\r\n    // Si es click derecho, va ciclando en las distintas marcas\r\n    if (currentStatus === cellStatus.COVERED_CLEAR)\r\n      return cellStatus.COVERED_FLAG;\r\n    if (currentStatus === cellStatus.COVERED_FLAG)\r\n      return cellStatus.COVERED_QUESTION;\r\n    if (currentStatus === cellStatus.COVERED_QUESTION)\r\n      return cellStatus.COVERED_CLEAR;\r\n  } else {\r\n    // Si es click izquierdo, descubre la celda\r\n    return cellStatus.UNCOVERED;\r\n  }\r\n};\r\n\r\n/**\r\n * Determina si ya es una victoria\r\n *\r\n * @param {Array} gameMatrix Matriz con la información del juego en el momento\r\n */\r\nexport const checkVictory = (gameMatrix) => {\r\n  for (let row = 0; row < gameMatrix.length; row++) {\r\n    for (let col = 0; col < gameMatrix[row].length; col++) {\r\n      const cell = gameMatrix[row][col];\r\n\r\n      // Para que haya victoria, cada celda tiene que estar descubierta o,\r\n      // si está cubierta, estar marcada con una bandera y ser efectivamente una mina\r\n\r\n      if (\r\n        cell.status !== cellStatus.UNCOVERED &&\r\n        (cell.status !== cellStatus.COVERED_FLAG || cell.type !== cellType.MINE)\r\n      ) {\r\n        return false;\r\n      }\r\n    }\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\n/**\r\n * Cambia a descubierto el estado de todas las celdas de una zona vacía a partir de las\r\n * coordenadas de una celda vacía descubierta\r\n *\r\n * @param {Array} gameMatrix Matriz de juego en estado actual\r\n * @param {number} row Fila de la celda vacía descubierta\r\n * @param {number} col Columna de la celda vacía descubierta\r\n */\r\nexport const uncoverEmptyCells = (gameMatrix, row, col) => {\r\n  // Se verifican las celdas adyacentes (si existen) y para cada una\r\n  // se vuelve a ejecutar recursivamente la función si también está\r\n  // vacía. Se actualiza la imagen que corresponde a cada celda\r\n\r\n  const lastRow = gameMatrix.length - 1;\r\n  const lastCol = gameMatrix[0].length - 1;\r\n\r\n  // Celda superior izquierda\r\n  if (row > 0 && col > 0) {\r\n    if (\r\n      gameMatrix[row - 1][col - 1].type === cellType.EMPTY &&\r\n      gameMatrix[row - 1][col - 1].status !== cellStatus.UNCOVERED\r\n    ) {\r\n      gameMatrix[row - 1][col - 1].status = cellStatus.UNCOVERED;\r\n      gameMatrix[row - 1][col - 1].image =\r\n        imageName.UNCOVERED_EMPTY_IMG_ROOT +\r\n        gameMatrix[row - 1][col - 1].nearMines;\r\n      if (gameMatrix[row - 1][col - 1].nearMines === 0) {\r\n        gameMatrix = uncoverEmptyCells(gameMatrix, row - 1, col - 1);\r\n      }\r\n    }\r\n  }\r\n\r\n  // Celda superior media\r\n  if (row > 0) {\r\n    if (\r\n      gameMatrix[row - 1][col].type === cellType.EMPTY &&\r\n      gameMatrix[row - 1][col].status !== cellStatus.UNCOVERED\r\n    ) {\r\n      gameMatrix[row - 1][col].status = cellStatus.UNCOVERED;\r\n      gameMatrix[row - 1][col].image =\r\n        imageName.UNCOVERED_EMPTY_IMG_ROOT + gameMatrix[row - 1][col].nearMines;\r\n      if (gameMatrix[row - 1][col].nearMines === 0) {\r\n        gameMatrix = uncoverEmptyCells(gameMatrix, row - 1, col);\r\n      }\r\n    }\r\n  }\r\n\r\n  // Celda superior derecha\r\n  if (row > 0 && col < lastCol) {\r\n    if (\r\n      gameMatrix[row - 1][col + 1].type === cellType.EMPTY &&\r\n      gameMatrix[row - 1][col + 1].status !== cellStatus.UNCOVERED\r\n    ) {\r\n      gameMatrix[row - 1][col + 1].status = cellStatus.UNCOVERED;\r\n      gameMatrix[row - 1][col + 1].image =\r\n        imageName.UNCOVERED_EMPTY_IMG_ROOT +\r\n        gameMatrix[row - 1][col + 1].nearMines;\r\n      if (gameMatrix[row - 1][col + 1].nearMines === 0) {\r\n        gameMatrix = uncoverEmptyCells(gameMatrix, row - 1, col + 1);\r\n      }\r\n    }\r\n  }\r\n\r\n  // Celda izquierda\r\n  if (col > 0) {\r\n    if (\r\n      gameMatrix[row][col - 1].type === cellType.EMPTY &&\r\n      gameMatrix[row][col - 1].status !== cellStatus.UNCOVERED\r\n    ) {\r\n      gameMatrix[row][col - 1].status = cellStatus.UNCOVERED;\r\n      gameMatrix[row][col - 1].image =\r\n        imageName.UNCOVERED_EMPTY_IMG_ROOT + gameMatrix[row][col - 1].nearMines;\r\n      if (gameMatrix[row][col - 1].nearMines === 0) {\r\n        gameMatrix = uncoverEmptyCells(gameMatrix, row, col - 1);\r\n      }\r\n    }\r\n  }\r\n\r\n  // Celda derecha\r\n  if (col < lastCol) {\r\n    if (\r\n      gameMatrix[row][col + 1].type === cellType.EMPTY &&\r\n      gameMatrix[row][col + 1].status !== cellStatus.UNCOVERED\r\n    ) {\r\n      gameMatrix[row][col + 1].status = cellStatus.UNCOVERED;\r\n      gameMatrix[row][col + 1].image =\r\n        imageName.UNCOVERED_EMPTY_IMG_ROOT + gameMatrix[row][col + 1].nearMines;\r\n      if (gameMatrix[row][col + 1].nearMines === 0) {\r\n        gameMatrix = uncoverEmptyCells(gameMatrix, row, col + 1);\r\n      }\r\n    }\r\n  }\r\n\r\n  // Celda inferior izquierda\r\n  if (row < lastRow && col > 0) {\r\n    if (\r\n      gameMatrix[row + 1][col - 1].type === cellType.EMPTY &&\r\n      gameMatrix[row + 1][col - 1].status !== cellStatus.UNCOVERED\r\n    ) {\r\n      gameMatrix[row + 1][col - 1].status = cellStatus.UNCOVERED;\r\n      gameMatrix[row + 1][col - 1].image =\r\n        imageName.UNCOVERED_EMPTY_IMG_ROOT +\r\n        gameMatrix[row + 1][col - 1].nearMines;\r\n      if (gameMatrix[row + 1][col - 1].nearMines === 0) {\r\n        gameMatrix = uncoverEmptyCells(gameMatrix, row + 1, col - 1);\r\n      }\r\n    }\r\n  }\r\n\r\n  // Celda inferior media\r\n  if (row < lastRow) {\r\n    if (\r\n      gameMatrix[row + 1][col].type === cellType.EMPTY &&\r\n      gameMatrix[row + 1][col].status !== cellStatus.UNCOVERED\r\n    ) {\r\n      gameMatrix[row + 1][col].status = cellStatus.UNCOVERED;\r\n      gameMatrix[row + 1][col].image =\r\n        imageName.UNCOVERED_EMPTY_IMG_ROOT + gameMatrix[row + 1][col].nearMines;\r\n      if (gameMatrix[row + 1][col].nearMines === 0) {\r\n        gameMatrix = uncoverEmptyCells(gameMatrix, row + 1, col);\r\n      }\r\n    }\r\n  }\r\n\r\n  // Celda inferior derecha\r\n  if (row < lastRow && col < lastCol) {\r\n    if (\r\n      gameMatrix[row + 1][col + 1].type === cellType.EMPTY &&\r\n      gameMatrix[row + 1][col + 1].status !== cellStatus.UNCOVERED\r\n    ) {\r\n      gameMatrix[row + 1][col + 1].status = cellStatus.UNCOVERED;\r\n      gameMatrix[row + 1][col + 1].image =\r\n        imageName.UNCOVERED_EMPTY_IMG_ROOT +\r\n        gameMatrix[row + 1][col + 1].nearMines;\r\n      if (gameMatrix[row + 1][col + 1].nearMines === 0) {\r\n        gameMatrix = uncoverEmptyCells(gameMatrix, row + 1, col + 1);\r\n      }\r\n    }\r\n  }\r\n\r\n  return gameMatrix;\r\n};\r\n\r\n\r\n/**\r\n * Revela todas las celdas que no hubieran sido reveladas ya\r\n * \r\n * @param {Array} gameMatrix \r\n */\r\nexport const uncoverAllCoveredCells = (gameMatrix) => {\r\n\r\n  for (let row = 0; row < gameMatrix.length; row++) {\r\n    for (let col = 0; col < gameMatrix[0].length; col++) {\r\n\r\n      if (gameMatrix[row][col].status !== cellStatus.UNCOVERED) {\r\n        gameMatrix[row][col].status = cellStatus.UNCOVERED;\r\n        gameMatrix[row][col].image = determineCellImage(gameMatrix[row][col], false);        \r\n      }\r\n\r\n    }\r\n    \r\n  }\r\n\r\n  return gameMatrix;\r\n}","import React, { Component } from \"react\";\r\nimport { cellStatus } from \"../gameLogic\";\r\n\r\nclass GameCell extends Component {\r\n  state = {\r\n    isUncovered: false,\r\n  };\r\n\r\n  handleLeftClick = () => {\r\n    this.props.notifyClick(false);\r\n  };\r\n\r\n  handleRightClick = (e) => {\r\n    // Evitar el menú contextual del navegador\r\n    e.preventDefault();\r\n\r\n    this.props.notifyClick(true);\r\n  };\r\n\r\n  render() {\r\n    return this.props.status !== cellStatus.UNCOVERED ? (\r\n      <div onClick={this.handleLeftClick} onContextMenu={this.handleRightClick}>\r\n        <img className=\"cell\" src={`${process.env.PUBLIC_URL}/img/box-${this.props.image}.png`} alt=\"\"/>\r\n      </div>\r\n    ) : (\r\n      <div>\r\n        <img className=\"cell\" src={`${process.env.PUBLIC_URL}/img/box-${this.props.image}.png`} alt=\"\"/>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default GameCell;\r\n","import React, { Component } from \"react\";\r\nimport { Button, Dialog, Grid, Paper, Typography } from \"@material-ui/core\";\r\nimport Draggable from \"react-draggable\";\r\n\r\nfunction PaperComponent(props) {\r\n  return (\r\n    <Draggable cancel={'button'}>\r\n      <Paper {...props} />\r\n    </Draggable>\r\n  );\r\n}\r\n\r\nclass GameOverDialog extends Component {\r\n  render() {\r\n    return (\r\n      <Dialog open={true} PaperComponent={PaperComponent}>\r\n        <Grid container direction=\"column\" justify=\"center\" alignItems=\"center\">\r\n          <img\r\n            src={\r\n              this.props.isVictory\r\n                ? `${process.env.PUBLIC_URL}/img/roman-victory.jpg`\r\n                : `${process.env.PUBLIC_URL}/img/roman-defeat.jpg`\r\n            }\r\n            alt=\"\"\r\n          />\r\n          <Button\r\n            id=\"btn-restart\"\r\n            className=\"btn-end-dialog\"\r\n            variant=\"contained\"\r\n            color=\"primary\"\r\n            onClick={this.props.restartGame}\r\n          >\r\n            Reiniciar con la misma configuración\r\n          </Button>\r\n          <Button\r\n            id=\"btn-backtomenu\"\r\n            className=\"btn-end-dialog\"\r\n            variant=\"contained\"\r\n            color=\"primary\"\r\n            onClick={this.props.backToMenu}\r\n          >\r\n            Volver al menú\r\n          </Button>\r\n          <Typography variant=\"caption\" className=\"footnote\">\r\n            (podés mover esta ventana si te tapa)\r\n          </Typography>\r\n        </Grid>\r\n      </Dialog>\r\n    );\r\n  }\r\n}\r\n\r\nexport default GameOverDialog;\r\n","import React, { Component } from \"react\";\r\nimport {\r\n  getNextStatus,\r\n  uncoverEmptyCells,\r\n  uncoverAllCoveredCells,\r\n  checkVictory,\r\n  cellStatus,\r\n  cellType,\r\n} from \"../gameLogic\";\r\nimport { Button } from \"@material-ui/core\";\r\nimport GameCell from \"./cell\";\r\nimport GameOverDialog from \"./gameOverDialog\";\r\nimport { determineCellImage } from \"../imgHelper\";\r\n\r\nclass GameGrid extends Component {\r\n  state = {\r\n    isGameOver: false,\r\n    isVictory: false,\r\n  };\r\n\r\n  // Crea la grilla\r\n  renderGameGrid = () => {\r\n    let cellsGrid = [];\r\n\r\n    // Se arma la grilla con la matriz de datos\r\n    for (let i = 0; i < this.props.gameMatrix.length; i++) {\r\n      let cellsRow = [];\r\n\r\n      for (let j = 0; j < this.props.gameMatrix[i].length; j++) {\r\n        // Se agrega la caja en la fila\r\n        cellsRow.push(\r\n          <GameCell\r\n            // key con gameId para que re-renderice cuando se reinicia el juego\r\n            key={`cell-${i}-${j}-game-${this.props.gameId}`}\r\n            image={this.props.gameMatrix[i][j].image}\r\n            status={this.props.gameMatrix[i][j].status}\r\n            notifyClick={(isRightClick) => this.onCellClick(i, j, isRightClick)}\r\n          />\r\n        );\r\n      }\r\n\r\n      // Se agrega la fila creada a la matriz\r\n      cellsGrid.push(\r\n        <div key={`row${i}_G${this.props.gameId}`} className=\"row\">\r\n          {cellsRow}\r\n        </div>\r\n      );\r\n    }\r\n\r\n    return cellsGrid;\r\n  };\r\n\r\n  // Recibe notificación de click en una celda, retorna imagen a mostrar\r\n  onCellClick(row, col, isRightClick) {\r\n    const clickedCell = this.props.gameMatrix[row][col];\r\n\r\n    // Si es click izquierdo en una celda que tiene bandera, se ignora\r\n    if (clickedCell.status === cellStatus.COVERED_FLAG && !isRightClick) return;\r\n\r\n    // Calcula el nuevo estado...\r\n    const newStatus = getNextStatus(clickedCell.status, isRightClick);\r\n\r\n    // ... y lo aplica en una copia de la matriz\r\n    let updatedGameMatrix = [...this.props.gameMatrix];\r\n    updatedGameMatrix[row][col].status = newStatus;\r\n\r\n    // Determina la imagen para el nuevo estado\r\n    updatedGameMatrix[row][col].image = determineCellImage(\r\n      updatedGameMatrix[row][col],\r\n      true\r\n    );\r\n\r\n    // Si se descubrió una celda vacía y sin minas cerca, se descubren las vacías aledañas\r\n    if (\r\n      newStatus === cellStatus.UNCOVERED &&\r\n      clickedCell.type === cellType.EMPTY &&\r\n      clickedCell.nearMines === 0\r\n    ) {\r\n      updatedGameMatrix = uncoverEmptyCells(updatedGameMatrix, row, col);\r\n    }\r\n\r\n    // Una vez actualizada, se controla si hay derrota o victoria\r\n\r\n    // Si quedó al descubierto y era una mina, perdió\r\n    // Si no, se chequean condiciones de victoria\r\n    if (\r\n      newStatus === cellStatus.UNCOVERED &&\r\n      clickedCell.type === cellType.MINE\r\n    ) {\r\n      // Se descubren las celdas y se muestra el modal de derrota\r\n      updatedGameMatrix = uncoverAllCoveredCells(updatedGameMatrix);\r\n\r\n      this.setState({\r\n        gameMatrix: updatedGameMatrix,\r\n        isGameOver: true,\r\n        isVictory: false,\r\n      });\r\n    } else if (checkVictory(updatedGameMatrix)) {\r\n      // TODO: si todas las celdas que quedan sin descubrir son minas, se\r\n      // debería dar por ganado igual y marcarlas automáticamente con banderas\r\n      this.setState({\r\n        isGameOver: true,\r\n        isVictory: true,\r\n      });\r\n    } else {\r\n      // Si no hay derrota ni victoria, solo actualiza la matriz de juego con los cambios\r\n      this.setState({\r\n        gameMatrix: updatedGameMatrix,\r\n      });\r\n    }\r\n  }\r\n\r\n  // Retorna al menú principal\r\n  backToMenu = () => {\r\n    this.setState({\r\n      isGameOver: false,\r\n    });\r\n\r\n    this.props.backToMenu();\r\n  };\r\n\r\n  // Reinicia con la misma configuración\r\n  restartGame = () => {\r\n    this.setState({\r\n      isGameOver: false,\r\n    });\r\n\r\n    this.props.restartGame();\r\n  };\r\n\r\n  renderGameOverModal = () => {\r\n    if (this.state.isGameOver) {\r\n      return (\r\n        <GameOverDialog\r\n          isVictory={this.state.isVictory}\r\n          restartGame={this.restartGame}\r\n          backToMenu={this.backToMenu}\r\n        />\r\n      );\r\n    }\r\n  };\r\n\r\n  handleSaveGameClick = () => {\r\n    this.props.saveGameAndReturnToMenu();\r\n  };\r\n\r\n  render() {\r\n    return (\r\n      <React.Fragment>\r\n        {this.renderGameGrid()}\r\n        {this.renderGameOverModal()}\r\n        <Button\r\n          onClick={this.handleSaveGameClick}\r\n          className=\"btn-separated\"\r\n          variant=\"contained\"\r\n          color=\"primary\"\r\n        >\r\n          Guardar juego y volver al menú\r\n        </Button>\r\n      </React.Fragment>\r\n    );\r\n  }\r\n}\r\n\r\nexport default GameGrid;\r\n","import React, { Component } from \"react\";\r\nimport { createGameMatrix } from \"../gameLogic\";\r\nimport GameGrid from \"./gameGrid\";\r\nimport { Grid, TextField, Button, Typography } from \"@material-ui/core\";\r\n\r\nclass Menu extends Component {\r\n  state = {\r\n    gameId: 0,\r\n    rows: 12,\r\n    cols: 10,\r\n    totalMines: 30,\r\n    mineProbability: 0,\r\n    gameMatrix: [],\r\n    gameOver: false,\r\n    showMenu: true,\r\n  };\r\n\r\n  // Calcula y muestra la probabilidad de minas una vez montado el componente\r\n  componentDidMount() {\r\n    this.setState({\r\n      mineProbability: this.calcMineProbability(\r\n        this.state.totalMines,\r\n        this.state.rows,\r\n        this.state.cols\r\n      ),\r\n    });\r\n  }\r\n\r\n  // Función para calcular la probabilidad de mina por celda\r\n  calcMineProbability = (mines, rows, cols) => {\r\n    const result = ((mines / (rows * cols)) * 100).toFixed(2);\r\n\r\n    return result > 100 ? 100 : result;\r\n  };\r\n\r\n  // Creación de un nuevo juego e inicio\r\n  startGame = () => {\r\n    const newGameMatrix = createGameMatrix(\r\n      parseInt(this.state.rows),\r\n      parseInt(this.state.cols),\r\n      parseInt(this.state.totalMines)\r\n    );\r\n\r\n    this.setState({\r\n      gameId: this.state.gameId + 1,\r\n      gameMatrix: newGameMatrix,\r\n      showMenu: false,\r\n    });\r\n  };\r\n\r\n  handleStartClick = () => {\r\n    localStorage.setItem(\"savedGame\", \"\");\r\n    this.startGame();\r\n  };\r\n\r\n  handleColsChange = (e) => {\r\n    this.setState({\r\n      cols: e.target.value,\r\n      mineProbability: this.calcMineProbability(\r\n        this.state.totalMines,\r\n        this.state.rows,\r\n        e.target.value\r\n      ),\r\n    });\r\n  };\r\n\r\n  handleRowsChange = (e) => {\r\n    this.setState({\r\n      rows: e.target.value,\r\n      mineProbability: this.calcMineProbability(\r\n        this.state.totalMines,\r\n        e.target.value,\r\n        this.state.cols\r\n      ),\r\n    });\r\n  };\r\n\r\n  handleMinesChange = (e) => {\r\n    this.setState({\r\n      totalMines: e.target.value,\r\n      mineProbability: this.calcMineProbability(\r\n        e.target.value,\r\n        this.state.rows,\r\n        this.state.cols\r\n      ),\r\n    });\r\n  };\r\n\r\n  restartGame = () => {\r\n    this.startGame();\r\n  };\r\n\r\n  showMenu = () => {\r\n    this.setState({\r\n      showMenu: true,\r\n    });\r\n  };\r\n\r\n  // Continuar juego guardado\r\n  handleContinueClick = () => {\r\n    const savedGameMatrix = JSON.parse(localStorage.getItem(\"savedGame\"));\r\n\r\n    console.log(savedGameMatrix);\r\n\r\n    this.setState({\r\n      gameId: this.state.gameId + 1,\r\n      gameMatrix: savedGameMatrix,\r\n      showMenu: false,\r\n    });\r\n  };\r\n\r\n  // Botón de Continuar juego si hay un juego guardado\r\n  renderContinueButton = () => {\r\n    if (localStorage.getItem(\"savedGame\")) {\r\n      return (\r\n        <Button\r\n          onClick={this.handleContinueClick}\r\n          color=\"primary\"\r\n          className=\"btn-separated\"\r\n        >\r\n          Continuar juego guardado\r\n        </Button>\r\n      );\r\n    }\r\n  };\r\n\r\n  // Guarda el juego actual y muestra el menú\r\n  saveGameAndShowMenu = () => {\r\n    localStorage.setItem(\"savedGame\", JSON.stringify(this.state.gameMatrix));\r\n    this.showMenu();\r\n  };\r\n\r\n  render() {\r\n    return this.state.showMenu ? (\r\n        <Grid\r\n          container\r\n          direction=\"column\"\r\n          justify=\"center\"\r\n          alignItems=\"flex-start\"\r\n        >\r\n          <TextField\r\n            className=\"menu-input\"\r\n            id=\"field-cols\"\r\n            label=\"Columnas\"\r\n            variant=\"outlined\"\r\n            type=\"number\"\r\n            defaultValue={this.state.cols}\r\n            onChange={this.handleColsChange}\r\n          />\r\n          <TextField\r\n            className=\"menu-input\"\r\n            id=\"field-rows\"\r\n            label=\"Filas\"\r\n            variant=\"outlined\"\r\n            type=\"number\"\r\n            defaultValue={this.state.rows}\r\n            onChange={this.handleRowsChange}\r\n          />\r\n          <TextField\r\n            className=\"menu-input\"\r\n            id=\"field-mines\"\r\n            label=\"Cantidad de minas\"\r\n            variant=\"outlined\"\r\n            type=\"number\"\r\n            defaultValue={this.state.totalMines}\r\n            onChange={this.handleMinesChange}\r\n          />\r\n          <Typography variant=\"overline\">\r\n            Probabilidad de mina: {this.state.mineProbability}%\r\n          </Typography>\r\n          <Button\r\n            onClick={this.handleStartClick}\r\n            variant=\"contained\"\r\n            color=\"primary\"\r\n          >\r\n            Jugar\r\n          </Button>\r\n          {this.renderContinueButton()}\r\n        </Grid>\r\n    ) : (\r\n      <GameGrid\r\n        key={`game${this.state.gameId}`}\r\n        gameId={this.state.gameId}\r\n        gameMatrix={this.state.gameMatrix}\r\n        restartGame={this.restartGame}\r\n        backToMenu={this.showMenu}\r\n        saveGameAndReturnToMenu={this.saveGameAndShowMenu}\r\n      />\r\n    );\r\n  }\r\n}\r\n\r\nexport default Menu;\r\n","import React, { Component } from 'react';\r\nimport { Grid } from \"@material-ui/core\";\r\n\r\nclass Header extends Component {\r\n    render() { \r\n        return (\r\n            <Grid container>\r\n                <Grid item xs={12}>\r\n                    <img className=\"logo\" src={`${process.env.PUBLIC_URL}/img/logo.jpg`} alt=\"\"/>\r\n                </Grid>\r\n            </Grid>\r\n        );\r\n    }\r\n}\r\n \r\nexport default Header;","import React from \"react\";\nimport \"./App.css\";\nimport Menu from \"./components/menu\";\nimport Header from \"./components/header\";\n\nfunction App() {\n  return (\n    <React.Fragment>\n      <Header />\n      <Menu />\n    </React.Fragment>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}